<!DOCTYPE html>
<html style="height:100%">
<head>
    <link rel="stylesheet" href="../assets/style.css">
    <script src="../assets/menu.js"></script>
</head>
<body style="height:100%">
<header>
    <title> Coderlingo</title>
    <h1>Sorting techniques</h1>
</header>

<div class="div_main">
    <div class="div_left">
        <div menu = "../assets/menu.html" style="float: left;clear: left;text-align:center;">
            <script>
            includeHTML();
            </script>
        </div>
    </div>
    <div class="div_right">
        Following list of techniques:
        <ul>
            <li><a href="#selection">Selection sort</a></li>
            <li><a href="#insertion">Insertion sort</a></li>
            <li><a href="#counting">Counting sort</a></li>
            <li><a href="#radix">Radix sort</a></li>
            <li>Bubble sort</li>
            <li>Merge sort</li>
            <li>Quick sort</li>
            <li>Heap sort</li>
            <li>Topological sort</li>
        </ul>
        <div id="selection">
     <h3>Selection sort</h3>
        Selection sort involves finding the smallest/largest element in the array and putting it in its correct position in each iteration. </br>
        We loop over the index, and over the remaining elements to find one for the index.</br>
        <b>Complexity:</b> O(n^2)

        <main>
            <figure>
                <figcaption>Selection Sort</figcaption>
                <pre>
                    <code>
        public static void selectionSort(int[] input) {
        for(int i=0;i&lt input.length;i++) {
            int min = i;
            <i>// find min in remaining unsorted array</i>
            for(int j=i+1;j&lt input.length;j++) {
                if(input[min]&gtinput[j]) {
                    min = j;
                }
            }
            <i>// swap to put min in correct index</i>
            if(min!=i) {
                int temp = input[min];
                input[min] = input[i];
                input[i] = temp;
            }
        }
    }
                    </code>
                </pre>
            </figure>
        </main>
        Refer to the working example <a href="https://github.com/coderlingo/algo-and-data-structures/blob/main/Sorting/src/SelectionSort.java">here</a>

    </div>
    <div id="insertion">
        <h3>Insertion sort</h3>
        Wroks similar to selection sort. But instead of putting an element in correct index in each iteration, it put the element in current index into its right position in partly sorted array </br>
        <b>Complexity:</b> O(n^2)

        <main>
            <figure>
                <figcaption>Insertion sort</figcaption>
                <pre>
                    <code>
       public static void insertionSort(int[] input) {
            for(int i=1;i&lt input.length;i++) {
                int val = input[i];
                int j;
                for(j=i-1;j &gt=0 && input[j]&gt val;j--) {
                    input[j+1] = input[j];
                }
                input[j+1] = val;
            }
        }
                    </code>
                </pre>
            </figure>
        </main>
        Refer to the working example <a href="https://github.com/coderlingo/algo-and-data-structures/blob/main/Sorting/src/InsertionSort.java">here</a>

    </div>

    <div id="counting">
        <h3>Counting Sort</h3>
        It is a liner time sort algorithm. It is achived by having additional knowledge of the range of the values in the list. We count the number of
        occurrence of each item and determine the index in the resultant sorted array.
        <b>Complexity:</b> O(n+k)

        <main>
            <figure>
                <figcaption>Counting sort</figcaption>
                <pre>
                    <code>
       public static void countingSort(int[] input, int range) {
            int[] count = new int[range+1];
            Arrays.stream(input).forEach(e->count[e]++);
            for(int i=1;i&lt count.length;i++) {
                count[i] = count[i-1]+count[i];
            }
            Arrays.fill(input,0);
            for(int i=1;i&lt count.length;i++) {
                if(count[i]!=count[i-1]) {
                    for(int j=count[i-1];j&lt count[i];j++) {
                        input[j] = i;
                    }
                }
            }
        }
                    </code>
                </pre>
            </figure>
        </main>
        Refer to the working example <a href="https://github.com/coderlingo/algo-and-data-structures/blob/main/Sorting/src/SelectionSort.java">here</a>

    </div>

        <div id="radix">
            <h3>Radix Sort</h3>
            Radix sort uses counting sort as an underlying algorithm. In radix sort we aim to reduce the dependen</br>
            <b>Complexity:</b> O((n+b)logb k)</br>
            n-> number of elments in array</br>
            b-> base of the sort.</br>
            k->largest element
            Let there be d digits in input integers. Radix Sort takes O(d*(n+b)) time where b is the base for representing numbers, for example, for the decimal system, b is 10. What is the value of d? If k is the maximum possible value, then d would be O(logb(k)). So overall time complexity is O((n+b) * logb(k)). Which looks more than the time complexity of comparison-based sorting algorithms for a large k. Let us first limit k. Let k <= nc where c is a constant. In that case, the complexity becomes O(nLogb(n)). But it still doesnâ€™t beat comparison-based sorting algorithms.
            What if we make the value of b larger?. What should be the value of b to make the time complexity linear? If we set b as n, we get the time complexity as O(n). In other words, we can sort an array of integers with a range from 1 to nc if the numbers are represented in base n (or every digit takes log2(n) bits).
            <main>
                <figure>
                    <figcaption>Radix sort</figcaption>
                    <pre>
                    <code>
       public static void countingSort(int[] input, int range, int pow) {
            int[] count = new int[range];
            int[] index = new int[range];
            int[] output = new int[input.length];

            Arrays.stream(input).forEach(e->count[(e/pow)%10]++);
            index[0] = count[0];
            for(int i=1;i&lt count.length;i++) {
                index[i] = index[i-1]+count[i];
            }
            for(int i =0;i&lt input.length;i++) {
                int idx = (input[i]/pow)%10;
                output[index[idx]-count[idx]] = input[i];
                count[idx]--;
            }
            for(int i = 0;i&lt input.length;i++) {
                input[i] = output[i];
            }
        }
        public static void radixSort(int[] input) {
            int n;
            int max = 0;
            for(int i=0;i&lt input.length;i++) {
                max = max>input[i]?max:input[i];
            }
            int i =1;
            while(max!=0) {
                countingSort(input,10,i);
                i=i*10;
                max = max/10;
            }
        }
                    </code>
                </pre>
                </figure>
            </main>
            Refer to the working example <a href="https://github.com/coderlingo/algo-and-data-structures/blob/main/Sorting/src/RadixSort.java">here</a>

        </div>
        <div id="bubble">
            <h3>Bubble Sort</h3>
            <b>Complexity:</b> O(n^2)</br>
            <main>
                <figure>
                    <figcaption>Radix sort</figcaption>
                    <pre>
                    <code>
    public static void bubbleSort(int[] input) {
        for(int i = 0;i&lt input.length;i++) {
         <i>// This flag helps to reduce the time. Since if we reach a point where the array is sorted, we dont want to
            // continue with the iterations and break out of the loop. In bubble sort, if no swaps happen in a pass of the array,
            // the array is sorted. </i>
            boolean flag = false;
            for(int j=0;j&lt input.length-i-1;j++) {
                if(input[j]>input[j+1]) {
                    flag = true;
                    int temp = input[j];
                    input[j] = input[j+1];
                    input[j+1] = temp;
                }
            }
            if(!flag){
                break;
            }
        }
    }
                    </code>
                </pre>
                </figure>
            </main>
            Refer to the working example <a href="https://github.com/coderlingo/algo-and-data-structures/blob/main/Sorting/src/BubbleSort.java">here</a>

        </div>
</div>
</div>
</body>