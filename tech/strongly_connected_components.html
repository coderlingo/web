<!DOCTYPE html>
<html>
<head style="height:100%">
    <link href="../assets/style.css" rel="stylesheet">
    <script src="../assets/menu.js"></script>
</head>
<body style="height:100%">
<header>
    <title>Strongly Connected Components</title>
    <h1>Strongly Connected Components</h1>
</header>
<div class="div_main">
    <div class="div_left">
        <div menu="../assets/menu.html" style="float: left;clear: left;text-align:center;">
            <script>
            includeHTML();
            </script>
        </div>
    </div>
    <div class="div_right">
        <p>Strongly connected components are a property of graphs. A sub-graph of a graph is a strongly connected component if there is a path between every pair
            of vertex.
        </p>
        </br>
        <b>Complexity:</b> The native approach of union-find works on O(n) where union adds the parent of one subset to the parent of another. If we end
        up adding the bigger tree as a child to the smaller each time, the find operation would end up running over a skewed tree.
        </br>
        To overcome this, we use union by rank, i.e., add smaller tree as the child of bigger. To make it even better we can add path compression.
        Where in, during find operation, we also flatten the tree along the branch we used to traverse to the parent.
        </br>
        <main>
            <figure>
                <figcaption>Union-Find without Rank and Path Compression</figcaption>
                <pre>
                    <code>
        public static int find(int[] parent, int a) {
        if(parent[a] !=a) {
            parent[a] = find(parent,parent[a]);
            return parent[a];
        } else
            return a;
        }
        public static int union(int[] parent,int[] rank, int a, int b) {
            int pA = find(parent, a);
            int pB = find(parent, b);
            if(pA!=pB) {
                if(rank[pA] < rank[pB]) {
                    parent[a] = pB;
                }
                else if(rank[pA] > rank[pB]) {
                    parent[b] = pA;
                } else {
                    parent[a] = pB;
                    rank[pB]++;
                }
                return 1;
            }
            return -1;
        }
                    </code>
                </pre>
            </figure>
        </main>
        Refer to the working example <a
            href="https://github.com/coderlingo/algo-and-data-structures/blob/main/union-find/src/UnionFind.java">here</a>
        <main>
            <figure>
                <figcaption>Union-Find with Rank and Path Compression</figcaption>
                <pre>
                    <code>
        public static int find(int[] parent, int a) {
        if(parent[a] !=a) {
            parent[a] = find(parent,parent[a]);
            return parent[a];
        } else
            return a;
        }
        public static int union(int[] parent,int[] rank, int a, int b) {
            int pA = find(parent, a);
            int pB = find(parent, b);
            if(pA!=pB) {
                if(rank[pA] < rank[pB]) {
                    parent[a] = pB;
                }
                else if(rank[pA] > rank[pB]) {
                    parent[b] = pA;
                } else {
                    parent[a] = pB;
                    rank[pB]++;
                }
                return 1;
            }
            return -1;
        }
                    </code>
                </pre>
            </figure>
        </main>
        Refer to the working example <a
            href="https://github.com/coderlingo/algo-and-data-structures/blob/main/union-find/src/UnionFindImproved.java">here</a>
    </div>
</div>
</body>